\hypertarget{graham__scan_8cpp}{}\doxysection{src/graham\+\_\+scan.cpp File Reference}
\label{graham__scan_8cpp}\index{src/graham\_scan.cpp@{src/graham\_scan.cpp}}
{\ttfamily \#include \char`\"{}graham\+\_\+scan.\+h\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{graham__scan_8cpp_a618017abca32b1862595aaef2103966f_a618017abca32b1862595aaef2103966f}{next\+Direction}} (\mbox{\hyperlink{structPoint}{Point}} p, \mbox{\hyperlink{structPoint}{Point}} q, \mbox{\hyperlink{structPoint}{Point}} r)
\item 
int \mbox{\hyperlink{graham__scan_8cpp_af4cf3349502d010047739b2ab085cc2a_af4cf3349502d010047739b2ab085cc2a}{get\+Leftmost\+Point}} (\mbox{\hyperlink{structPoint}{Point}} p\mbox{[}$\,$\mbox{]}, int n)
\begin{DoxyCompactList}\small\item\em Finds the leftmost point and then brings it to index 0. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{graham__scan_8cpp_a3a6cdf3ade49b9308d2b1a013f323feb_a3a6cdf3ade49b9308d2b1a013f323feb}{remove\+Theta\+Collinear}} (\mbox{\hyperlink{structPolarPoint}{Polar\+Point}} inp\mbox{[}$\,$\mbox{]}, int n, \mbox{\hyperlink{structPolarPoint}{Polar\+Point}} out\mbox{[}$\,$\mbox{]})
\item 
void \mbox{\hyperlink{graham__scan_8cpp_a8cddc685da2081393fe86f85e4fee48c_a8cddc685da2081393fe86f85e4fee48c}{sort\+Points}} (\mbox{\hyperlink{structPolarPoint}{Polar\+Point}} inp\mbox{[}$\,$\mbox{]}, int n)
\begin{DoxyCompactList}\small\item\em A in-\/place sort of all points. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{graham__scan_8cpp_a1a44af4324b96b2e7425f57fe1d4d3b4_a1a44af4324b96b2e7425f57fe1d4d3b4}{compute\+Hull}} (\mbox{\hyperlink{structPoint}{Point}} inp\mbox{[}$\,$\mbox{]}, int n, \mbox{\hyperlink{convex__hull__structs_8h_structNode}{Node}} $\ast$$\ast$root)
\item 
int \mbox{\hyperlink{graham__scan_8cpp_a29aadae86c3a4e9b729b60606c212b88_a29aadae86c3a4e9b729b60606c212b88}{get\+Hull}} (\mbox{\hyperlink{structPoint}{Point}} input\mbox{[}$\,$\mbox{]}, int len, \mbox{\hyperlink{convex__hull__structs_8h_structNode}{Node}} $\ast$$\ast$root)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{graham__scan_8cpp_a1a44af4324b96b2e7425f57fe1d4d3b4_a1a44af4324b96b2e7425f57fe1d4d3b4}\label{graham__scan_8cpp_a1a44af4324b96b2e7425f57fe1d4d3b4_a1a44af4324b96b2e7425f57fe1d4d3b4}} 
\index{graham\_scan.cpp@{graham\_scan.cpp}!computeHull@{computeHull}}
\index{computeHull@{computeHull}!graham\_scan.cpp@{graham\_scan.cpp}}
\doxysubsubsection{\texorpdfstring{computeHull()}{computeHull()}}
{\footnotesize\ttfamily int compute\+Hull (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structPoint}{Point}}}]{inp\mbox{[}$\,$\mbox{]},  }\item[{int}]{n,  }\item[{\mbox{\hyperlink{convex__hull__structs_8h_structNode}{Node}} $\ast$$\ast$}]{root }\end{DoxyParamCaption})}

Adds the points that are the vertices of the convex hull into the passed stack 
\begin{DoxyParams}{Parameters}
{\em inp} & Array of all points in cartesian form; sorted \\
\hline
{\em n} & length of the array \\
\hline
{\em root} & pointer to the root node pointer of a stack \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of points on the hull 
\end{DoxyReturn}


Definition at line 108 of file graham\+\_\+scan.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{109 \{}
\DoxyCodeLine{110     \textcolor{keywordtype}{int} size = 0;}
\DoxyCodeLine{111     \textcolor{comment}{//Add the origin and next point to the Hull}}
\DoxyCodeLine{112     \mbox{\hyperlink{convex__hull__structs_8cpp_aedc86384e642229c1ede4b544cad62a7_aedc86384e642229c1ede4b544cad62a7}{push}}(inp[size++], root); \textcolor{comment}{// 0-\/>1}}
\DoxyCodeLine{113     \mbox{\hyperlink{convex__hull__structs_8cpp_aedc86384e642229c1ede4b544cad62a7_aedc86384e642229c1ede4b544cad62a7}{push}}(inp[size++], root); \textcolor{comment}{// 1-\/>2}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 2; i < n-\/1; i++ )}
\DoxyCodeLine{116     \{}
\DoxyCodeLine{117         \textcolor{comment}{// cout << "(" << peek(root).x << " " << peek(root).y << ") ";}}
\DoxyCodeLine{118         \textcolor{comment}{// cout << "(" << inp[i].x << " " << inp[i].y << ") ";}}
\DoxyCodeLine{119         \textcolor{comment}{// cout << "(" << inp[i+1].x << " " << inp[i+1].y << ") ";}}
\DoxyCodeLine{120         \textcolor{comment}{// cout << nextDirection(peek(root),inp[i],inp[i+1]) << endl;}}
\DoxyCodeLine{121         \textcolor{keywordflow}{if}(\mbox{\hyperlink{graham__scan_8cpp_a618017abca32b1862595aaef2103966f_a618017abca32b1862595aaef2103966f}{nextDirection}}(\mbox{\hyperlink{convex__hull__structs_8cpp_a51445a281da33cd0292c2645c1daabbd_a51445a281da33cd0292c2645c1daabbd}{peek}}(root),inp[i],inp[i+1]) < 0)}
\DoxyCodeLine{122         \{}
\DoxyCodeLine{123             \textcolor{comment}{//The code below running means occurence of a right turn. If collinear point not to be taken, make <=}}
\DoxyCodeLine{124             \mbox{\hyperlink{structPoint}{Point}} popped = \mbox{\hyperlink{convex__hull__structs_8cpp_a17c7cdc313c0ae96a4d4de67508f4fa8_a17c7cdc313c0ae96a4d4de67508f4fa8}{pop}}(root);}
\DoxyCodeLine{125             size-\/-\/;}
\DoxyCodeLine{126             \textcolor{comment}{// Keep popping till left turn arises}}
\DoxyCodeLine{127             \textcolor{keywordflow}{while} (\mbox{\hyperlink{graham__scan_8cpp_a618017abca32b1862595aaef2103966f_a618017abca32b1862595aaef2103966f}{nextDirection}}(popped, \mbox{\hyperlink{convex__hull__structs_8cpp_a51445a281da33cd0292c2645c1daabbd_a51445a281da33cd0292c2645c1daabbd}{peek}}(root), inp[i+1]) >= 0 \&\& !\mbox{\hyperlink{convex__hull__structs_8cpp_ab56360be26c85a59f8bbeec961fe622d_ab56360be26c85a59f8bbeec961fe622d}{isEmpty}}(*root))}
\DoxyCodeLine{128             \{}
\DoxyCodeLine{129                 \textcolor{comment}{// cout << "while: popped" <<endl;}}
\DoxyCodeLine{130                 popped = \mbox{\hyperlink{convex__hull__structs_8cpp_a17c7cdc313c0ae96a4d4de67508f4fa8_a17c7cdc313c0ae96a4d4de67508f4fa8}{pop}}(root);}
\DoxyCodeLine{131                 size-\/-\/;}
\DoxyCodeLine{132             \}}
\DoxyCodeLine{133             \mbox{\hyperlink{convex__hull__structs_8cpp_aedc86384e642229c1ede4b544cad62a7_aedc86384e642229c1ede4b544cad62a7}{push}}(popped,root);}
\DoxyCodeLine{134             size++;}
\DoxyCodeLine{135         \}}
\DoxyCodeLine{136         \textcolor{keywordflow}{else}}
\DoxyCodeLine{137         \{}
\DoxyCodeLine{138             \mbox{\hyperlink{convex__hull__structs_8cpp_aedc86384e642229c1ede4b544cad62a7_aedc86384e642229c1ede4b544cad62a7}{push}}(inp[i],root);}
\DoxyCodeLine{139             \textcolor{comment}{// cout << "pushed" << endl;}}
\DoxyCodeLine{140             size++;}
\DoxyCodeLine{141         \}}
\DoxyCodeLine{142     \}}
\DoxyCodeLine{143     \mbox{\hyperlink{convex__hull__structs_8cpp_aedc86384e642229c1ede4b544cad62a7_aedc86384e642229c1ede4b544cad62a7}{push}}(inp[n-\/1],root);}
\DoxyCodeLine{144     size++;}
\DoxyCodeLine{145     \textcolor{keyword}{delete} inp;}
\DoxyCodeLine{146     \textcolor{keywordflow}{return} size;}
\DoxyCodeLine{147 \}}

\end{DoxyCode}


References is\+Empty(), next\+Direction(), peek(), pop(), and push().



Referenced by get\+Hull().

\mbox{\Hypertarget{graham__scan_8cpp_a29aadae86c3a4e9b729b60606c212b88_a29aadae86c3a4e9b729b60606c212b88}\label{graham__scan_8cpp_a29aadae86c3a4e9b729b60606c212b88_a29aadae86c3a4e9b729b60606c212b88}} 
\index{graham\_scan.cpp@{graham\_scan.cpp}!getHull@{getHull}}
\index{getHull@{getHull}!graham\_scan.cpp@{graham\_scan.cpp}}
\doxysubsubsection{\texorpdfstring{getHull()}{getHull()}}
{\footnotesize\ttfamily int get\+Hull (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structPoint}{Point}}}]{input\mbox{[}$\,$\mbox{]},  }\item[{int}]{len,  }\item[{\mbox{\hyperlink{convex__hull__structs_8h_structNode}{Node}} $\ast$$\ast$}]{root }\end{DoxyParamCaption})}

The single function that needs to be called in order to get the vertices of the convex hull using Graham\textquotesingle{}s Scan algo 
\begin{DoxyParams}{Parameters}
{\em input} & Input array of Points \\
\hline
{\em len} & Length of array \\
\hline
{\em root} & Stack root node to which vertices will be pushed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of points on the hull 
\end{DoxyReturn}


Definition at line 156 of file graham\+\_\+scan.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{157 \{}
\DoxyCodeLine{158     \textcolor{comment}{// Get the leftmost point}}
\DoxyCodeLine{159     \textcolor{keywordtype}{int} ind = \mbox{\hyperlink{graham__scan_8cpp_af4cf3349502d010047739b2ab085cc2a_af4cf3349502d010047739b2ab085cc2a}{getLeftmostPoint}}(input,len);}
\DoxyCodeLine{160     \mbox{\hyperlink{structPoint}{Point}} origin = input[ind];}
\DoxyCodeLine{161     \mbox{\hyperlink{structPolarPoint}{PolarPoint}}* input\_pol= \textcolor{keyword}{new} \mbox{\hyperlink{structPolarPoint}{PolarPoint}}[len];}
\DoxyCodeLine{162 }
\DoxyCodeLine{163     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < len; i++)}
\DoxyCodeLine{164     \{}
\DoxyCodeLine{165         input\_pol[i] = \mbox{\hyperlink{convex__hull__structs_8cpp_a93d2730657e69fb490d7aa7759d405e8_a93d2730657e69fb490d7aa7759d405e8}{convertToPolar}}(input[i],origin);}
\DoxyCodeLine{166     \}}
\DoxyCodeLine{167     \textcolor{comment}{// If an array is defined as <type>* <arrayname> = new <type>[len] (Basically using the new operator), then the delete [] <arrayName> method can be safely used}}
\DoxyCodeLine{168     \textcolor{comment}{// The arrays of form <type> <arrayName>[len] are called statically allocated arrays. Their memory cannot be freed}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170     \textcolor{comment}{// printf("\%s\(\backslash\)n","Printing unsorted polar array" );}}
\DoxyCodeLine{171     \textcolor{comment}{// printArray(input\_pol,len);}}
\DoxyCodeLine{172 }
\DoxyCodeLine{173     \mbox{\hyperlink{convex__hull__structs_8cpp_a5b3cfcff2087be4b127f3adc283e8a7b_a5b3cfcff2087be4b127f3adc283e8a7b}{swap}}(0, ind, input\_pol); \textcolor{comment}{// Origin is now at index0 in input\_pol}}
\DoxyCodeLine{174     \mbox{\hyperlink{graham__scan_8cpp_a8cddc685da2081393fe86f85e4fee48c_a8cddc685da2081393fe86f85e4fee48c}{sortPoints}}(input\_pol+ 1, len-\/1); \textcolor{comment}{// input\_pol[1:]}}
\DoxyCodeLine{175     \textcolor{comment}{// printf("\%s\(\backslash\)n","Printing sorted polar array" );}}
\DoxyCodeLine{176     \textcolor{comment}{// printArray(input\_pol,len);}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178     \textcolor{comment}{// Remove Collinear Points}}
\DoxyCodeLine{179     \mbox{\hyperlink{structPolarPoint}{PolarPoint}}* intermediate\_pol = \textcolor{keyword}{new} \mbox{\hyperlink{structPolarPoint}{PolarPoint}}[len];}
\DoxyCodeLine{180     \textcolor{keywordtype}{int} newlen = 0;}
\DoxyCodeLine{181     newlen = \mbox{\hyperlink{graham__scan_8cpp_a3a6cdf3ade49b9308d2b1a013f323feb_a3a6cdf3ade49b9308d2b1a013f323feb}{removeThetaCollinear}}(input\_pol,len,intermediate\_pol);}
\DoxyCodeLine{182     \textcolor{comment}{// printf("\%s\(\backslash\)n","Printing intermediate polar array");}}
\DoxyCodeLine{183     \textcolor{comment}{// printArray(intermediate\_pol,newlen);}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185     \textcolor{keywordflow}{if}(newlen < 3)}
\DoxyCodeLine{186     \{}
\DoxyCodeLine{187         printf(\textcolor{stringliteral}{"\%s\(\backslash\)n"}, \textcolor{stringliteral}{"Convex hull not possible"});}
\DoxyCodeLine{188         \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{189     \}}
\DoxyCodeLine{190 }
\DoxyCodeLine{191     \mbox{\hyperlink{structPoint}{Point}}* intermediate\_cart = \textcolor{keyword}{new} \mbox{\hyperlink{structPoint}{Point}}[newlen];}
\DoxyCodeLine{192     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < newlen; i++)}
\DoxyCodeLine{193     \{}
\DoxyCodeLine{194         intermediate\_cart[i] = input[intermediate\_pol[i].\mbox{\hyperlink{structPolarPoint_a5f91e80d809f15a3beed431d9792d28c_a5f91e80d809f15a3beed431d9792d28c}{index}}];}
\DoxyCodeLine{195     \}}
\DoxyCodeLine{196     \textcolor{keyword}{delete} [] intermediate\_pol;}
\DoxyCodeLine{197     \textcolor{keyword}{delete} [] input\_pol;}
\DoxyCodeLine{198 }
\DoxyCodeLine{199     \textcolor{comment}{// printf("\%s\(\backslash\)n","Printing intermediate cart array");}}
\DoxyCodeLine{200     \textcolor{comment}{// printArray(intermediate\_cart,newlen);}}
\DoxyCodeLine{201 }
\DoxyCodeLine{202     \textcolor{keywordflow}{return} \mbox{\hyperlink{graham__scan_8cpp_a1a44af4324b96b2e7425f57fe1d4d3b4_a1a44af4324b96b2e7425f57fe1d4d3b4}{computeHull}}(intermediate\_cart,newlen,root);}
\DoxyCodeLine{203 \}}

\end{DoxyCode}


References compute\+Hull(), convert\+To\+Polar(), get\+Leftmost\+Point(), Polar\+Point\+::index, remove\+Theta\+Collinear(), sort\+Points(), and swap().



Referenced by main().

\mbox{\Hypertarget{graham__scan_8cpp_af4cf3349502d010047739b2ab085cc2a_af4cf3349502d010047739b2ab085cc2a}\label{graham__scan_8cpp_af4cf3349502d010047739b2ab085cc2a_af4cf3349502d010047739b2ab085cc2a}} 
\index{graham\_scan.cpp@{graham\_scan.cpp}!getLeftmostPoint@{getLeftmostPoint}}
\index{getLeftmostPoint@{getLeftmostPoint}!graham\_scan.cpp@{graham\_scan.cpp}}
\doxysubsubsection{\texorpdfstring{getLeftmostPoint()}{getLeftmostPoint()}}
{\footnotesize\ttfamily int get\+Leftmost\+Point (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structPoint}{Point}}}]{p\mbox{[}$\,$\mbox{]},  }\item[{int}]{n }\end{DoxyParamCaption})}



Finds the leftmost point and then brings it to index 0. 


\begin{DoxyParams}{Parameters}
{\em p} & Array of \mbox{\hyperlink{structPoint}{Point}} objects \\
\hline
{\em n} & length of the array \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
index of leftmost point 
\end{DoxyReturn}


Definition at line 22 of file graham\+\_\+scan.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{23 \{}
\DoxyCodeLine{24     \textcolor{keywordtype}{int} index\_ref = 0;}
\DoxyCodeLine{25     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < n; i++)}
\DoxyCodeLine{26     \{}
\DoxyCodeLine{27         \textcolor{keywordflow}{if}(p[i].x < p[index\_ref].x)}
\DoxyCodeLine{28         \{}
\DoxyCodeLine{29             index\_ref = i;}
\DoxyCodeLine{30         \}}
\DoxyCodeLine{31         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(p[i].x == p[index\_ref].x)}
\DoxyCodeLine{32         \{}
\DoxyCodeLine{33             \textcolor{keywordflow}{if}(p[i].y < p[index\_ref].y)}
\DoxyCodeLine{34             \{}
\DoxyCodeLine{35                 index\_ref = i;}
\DoxyCodeLine{36             \}}
\DoxyCodeLine{37         \}}
\DoxyCodeLine{38     \}}
\DoxyCodeLine{39     \textcolor{keywordflow}{return} index\_ref;}
\DoxyCodeLine{40 \}}

\end{DoxyCode}


Referenced by get\+Hull().

\mbox{\Hypertarget{graham__scan_8cpp_a618017abca32b1862595aaef2103966f_a618017abca32b1862595aaef2103966f}\label{graham__scan_8cpp_a618017abca32b1862595aaef2103966f_a618017abca32b1862595aaef2103966f}} 
\index{graham\_scan.cpp@{graham\_scan.cpp}!nextDirection@{nextDirection}}
\index{nextDirection@{nextDirection}!graham\_scan.cpp@{graham\_scan.cpp}}
\doxysubsubsection{\texorpdfstring{nextDirection()}{nextDirection()}}
{\footnotesize\ttfamily double next\+Direction (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structPoint}{Point}}}]{p,  }\item[{\mbox{\hyperlink{structPoint}{Point}}}]{q,  }\item[{\mbox{\hyperlink{structPoint}{Point}}}]{r }\end{DoxyParamCaption})}

Computes whether the next point is to the left or to the right or in the same direction. 
\begin{DoxyParams}{Parameters}
{\em p} & The previous point \\
\hline
{\em q} & The point common to both segments, i.\+e. current point \\
\hline
{\em r} & The next point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 for same direction, positive value for left turn and negative value for right turn 
\end{DoxyReturn}


Definition at line 10 of file graham\+\_\+scan.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{11 \{}
\DoxyCodeLine{12     \textcolor{comment}{// A positive cross product indicates left, while a negative one indicates right.}}
\DoxyCodeLine{13     \textcolor{keywordflow}{return} (q.\mbox{\hyperlink{structPoint_ab99c56589bc8ad5fa5071387110a5bc7_ab99c56589bc8ad5fa5071387110a5bc7}{x}} -\/ p.\mbox{\hyperlink{structPoint_ab99c56589bc8ad5fa5071387110a5bc7_ab99c56589bc8ad5fa5071387110a5bc7}{x}})*(r.\mbox{\hyperlink{structPoint_afa38be143ae800e6ad69ce8ed4df62d8_afa38be143ae800e6ad69ce8ed4df62d8}{y}} -\/ q.\mbox{\hyperlink{structPoint_afa38be143ae800e6ad69ce8ed4df62d8_afa38be143ae800e6ad69ce8ed4df62d8}{y}}) -\/ (r.\mbox{\hyperlink{structPoint_ab99c56589bc8ad5fa5071387110a5bc7_ab99c56589bc8ad5fa5071387110a5bc7}{x}} -\/ q.\mbox{\hyperlink{structPoint_ab99c56589bc8ad5fa5071387110a5bc7_ab99c56589bc8ad5fa5071387110a5bc7}{x}})*(q.\mbox{\hyperlink{structPoint_afa38be143ae800e6ad69ce8ed4df62d8_afa38be143ae800e6ad69ce8ed4df62d8}{y}} -\/ p.\mbox{\hyperlink{structPoint_afa38be143ae800e6ad69ce8ed4df62d8_afa38be143ae800e6ad69ce8ed4df62d8}{y}});}
\DoxyCodeLine{14 \}}

\end{DoxyCode}


References Point\+::x, and Point\+::y.



Referenced by compute\+Hull().

\mbox{\Hypertarget{graham__scan_8cpp_a3a6cdf3ade49b9308d2b1a013f323feb_a3a6cdf3ade49b9308d2b1a013f323feb}\label{graham__scan_8cpp_a3a6cdf3ade49b9308d2b1a013f323feb_a3a6cdf3ade49b9308d2b1a013f323feb}} 
\index{graham\_scan.cpp@{graham\_scan.cpp}!removeThetaCollinear@{removeThetaCollinear}}
\index{removeThetaCollinear@{removeThetaCollinear}!graham\_scan.cpp@{graham\_scan.cpp}}
\doxysubsubsection{\texorpdfstring{removeThetaCollinear()}{removeThetaCollinear()}}
{\footnotesize\ttfamily int remove\+Theta\+Collinear (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structPolarPoint}{Polar\+Point}}}]{inp\mbox{[}$\,$\mbox{]},  }\item[{int}]{n,  }\item[{\mbox{\hyperlink{structPolarPoint}{Polar\+Point}}}]{out\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}

If multiple points have the same angle, then only the one with largest radius remains in the out array 
\begin{DoxyParams}{Parameters}
{\em inp} & Array of points in Polar form. This M\+U\+ST be sorted before being passed \\
\hline
{\em n} & Length of array \\
\hline
{\em out} & an array of valid points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the length of the out array 
\end{DoxyReturn}


Definition at line 49 of file graham\+\_\+scan.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{50 \{}
\DoxyCodeLine{51     \textcolor{keywordtype}{int} newlen = 0;}
\DoxyCodeLine{52     out[newlen++] = inp[0]; \textcolor{comment}{//maintaining origin first}}
\DoxyCodeLine{53     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 1; i < n-\/1 ; i++)}
\DoxyCodeLine{54     \{}
\DoxyCodeLine{55         \textcolor{keywordflow}{if}(\mbox{\hyperlink{convex__hull__structs_8cpp_aec3e303159001a1c4d68d9b54aa9ebb2_aec3e303159001a1c4d68d9b54aa9ebb2}{compareTheta}}(inp[i],inp[i+1]) == 0)}
\DoxyCodeLine{56         \{}
\DoxyCodeLine{57             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{58         \}}
\DoxyCodeLine{59         \textcolor{keywordflow}{else}}
\DoxyCodeLine{60         \{}
\DoxyCodeLine{61             out[newlen++] = inp[i];}
\DoxyCodeLine{62         \}}
\DoxyCodeLine{63     \}}
\DoxyCodeLine{64     out[newlen++] = inp[n-\/1]; \textcolor{comment}{// no further item to check with. Is always added.}}
\DoxyCodeLine{65     \textcolor{keywordflow}{return} newlen;}
\DoxyCodeLine{66 \}}

\end{DoxyCode}


References compare\+Theta().



Referenced by get\+Hull().

\mbox{\Hypertarget{graham__scan_8cpp_a8cddc685da2081393fe86f85e4fee48c_a8cddc685da2081393fe86f85e4fee48c}\label{graham__scan_8cpp_a8cddc685da2081393fe86f85e4fee48c_a8cddc685da2081393fe86f85e4fee48c}} 
\index{graham\_scan.cpp@{graham\_scan.cpp}!sortPoints@{sortPoints}}
\index{sortPoints@{sortPoints}!graham\_scan.cpp@{graham\_scan.cpp}}
\doxysubsubsection{\texorpdfstring{sortPoints()}{sortPoints()}}
{\footnotesize\ttfamily void sort\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structPolarPoint}{Polar\+Point}}}]{inp\mbox{[}$\,$\mbox{]},  }\item[{int}]{n }\end{DoxyParamCaption})}



A in-\/place sort of all points. 

Points are sorted according to increasing angle, then radius. The leftmost point is not passed to the function to ensure that inp\mbox{[}0\mbox{]} is the origin (0.\+0,0.\+0). If this is not done, the points below origin (theta $<$ 0) are before it in the array, which is not our desired traversal path. O(n$^\wedge$2) complexity. Can be brought to O(nlogn) by using a Quick\+Sort or other appropriate algorithm 
\begin{DoxyParams}{Parameters}
{\em inp} & Array of points in polar representation \\
\hline
{\em n} & Length of the array \\
\hline
\end{DoxyParams}


Definition at line 77 of file graham\+\_\+scan.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{78 \{}
\DoxyCodeLine{79     \textcolor{comment}{//Bubble sort}}
\DoxyCodeLine{80     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k < n-\/1; k++)}
\DoxyCodeLine{81     \{}
\DoxyCodeLine{82         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n-\/k-\/1; i++)}
\DoxyCodeLine{83         \{}
\DoxyCodeLine{84             \textcolor{keywordflow}{if}(inp[i].theta > inp[i+1].theta)}
\DoxyCodeLine{85             \{}
\DoxyCodeLine{86                 \textcolor{comment}{//swap since angle}}
\DoxyCodeLine{87                 \mbox{\hyperlink{convex__hull__structs_8cpp_a5b3cfcff2087be4b127f3adc283e8a7b_a5b3cfcff2087be4b127f3adc283e8a7b}{swap}}(i,i+1,inp);}
\DoxyCodeLine{88             \}}
\DoxyCodeLine{89             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(inp[i].theta == inp[i+1].theta)}
\DoxyCodeLine{90             \{}
\DoxyCodeLine{91                 \textcolor{keywordflow}{if}(inp[i].r > inp[i+1].r)}
\DoxyCodeLine{92                 \{}
\DoxyCodeLine{93                     \textcolor{comment}{//swap since radius}}
\DoxyCodeLine{94                     \mbox{\hyperlink{convex__hull__structs_8cpp_a5b3cfcff2087be4b127f3adc283e8a7b_a5b3cfcff2087be4b127f3adc283e8a7b}{swap}}(i,i+1,inp);}
\DoxyCodeLine{95                 \}}
\DoxyCodeLine{96             \}}
\DoxyCodeLine{97         \}}
\DoxyCodeLine{98     \}}
\DoxyCodeLine{99 \}}

\end{DoxyCode}


References swap().



Referenced by get\+Hull().

